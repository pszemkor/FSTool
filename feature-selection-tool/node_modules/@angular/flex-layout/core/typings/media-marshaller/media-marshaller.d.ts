import { Observable } from 'rxjs';
import { BreakPointRegistry } from '../breakpoints/break-point-registry';
import { MatchMedia } from '../match-media/match-media';
import { MediaChange } from '../media-change';
import { PrintHook } from './print-hook';
import * as ɵngcc0 from '@angular/core';
declare type ClearCallback = () => void;
declare type UpdateCallback = (val: any) => void;
export interface ElementMatcher {
    element: HTMLElement;
    key: string;
    value: any;
}
/**
 * MediaMarshaller - register responsive values from directives and
 *                   trigger them based on media query events
 */
export declare class MediaMarshaller {
    protected matchMedia: MatchMedia;
    protected breakpoints: BreakPointRegistry;
    protected hook: PrintHook;
    private activatedBreakpoints;
    private elementMap;
    private elementKeyMap;
    private watcherMap;
    private updateMap;
    private clearMap;
    private subject;
    get activatedAlias(): string;
    constructor(matchMedia: MatchMedia, breakpoints: BreakPointRegistry, hook: PrintHook);
    /**
     * Update styles on breakpoint activates or deactivates
     * @param mc
     */
    onMediaChange(mc: MediaChange): void;
    /**
     * initialize the marshaller with necessary elements for delegation on an element
     * @param element
     * @param key
     * @param updateFn optional callback so that custom bp directives don't have to re-provide this
     * @param clearFn optional callback so that custom bp directives don't have to re-provide this
     * @param extraTriggers other triggers to force style updates (e.g. layout, directionality, etc)
     */
    init(element: HTMLElement, key: string, updateFn?: UpdateCallback, clearFn?: ClearCallback, extraTriggers?: Observable<any>[]): void;
    /**
     * get the value for an element and key and optionally a given breakpoint
     * @param element
     * @param key
     * @param bp
     */
    getValue(element: HTMLElement, key: string, bp?: string): any;
    /**
     * whether the element has values for a given key
     * @param element
     * @param key
     */
    hasValue(element: HTMLElement, key: string): boolean;
    /**
     * Set the value for an input on a directive
     * @param element the element in question
     * @param key the type of the directive (e.g. flex, layout-gap, etc)
     * @param bp the breakpoint suffix (empty string = default)
     * @param val the value for the breakpoint
     */
    setValue(element: HTMLElement, key: string, val: any, bp: string): void;
    /** Track element value changes for a specific key */
    trackValue(element: HTMLElement, key: string): Observable<ElementMatcher>;
    /** update all styles for all elements on the current breakpoint */
    updateStyles(): void;
    /**
     * clear the styles for a given element
     * @param element
     * @param key
     */
    clearElement(element: HTMLElement, key: string): void;
    /**
     * update a given element with the activated values for a given key
     * @param element
     * @param key
     * @param value
     */
    updateElement(element: HTMLElement, key: string, value: any): void;
    /**
     * release all references to a given element
     * @param element
     */
    releaseElement(element: HTMLElement): void;
    /**
     * trigger an update for a given element and key (e.g. layout)
     * @param element
     * @param key
     */
    triggerUpdate(element: HTMLElement, key?: string): void;
    /** Cross-reference for HTMLElement with directive key */
    private buildElementKeyMap;
    /**
     * Other triggers that should force style updates:
     * - directionality
     * - layout changes
     * - mutationobserver updates
     */
    private watchExtraTriggers;
    /** Breakpoint locator by mediaQuery */
    private findByQuery;
    /**
     * get the fallback breakpoint for a given element, starting with the current breakpoint
     * @param bpMap
     * @param key
     */
    private getActivatedValues;
    /**
     * Watch for mediaQuery breakpoint activations
     */
    private observeActivations;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MediaMarshaller, never>;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVkaWEtbWFyc2hhbGxlci5kLnRzIiwic291cmNlcyI6WyJtZWRpYS1tYXJzaGFsbGVyLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEJyZWFrUG9pbnRSZWdpc3RyeSB9IGZyb20gJy4uL2JyZWFrcG9pbnRzL2JyZWFrLXBvaW50LXJlZ2lzdHJ5JztcbmltcG9ydCB7IE1hdGNoTWVkaWEgfSBmcm9tICcuLi9tYXRjaC1tZWRpYS9tYXRjaC1tZWRpYSc7XG5pbXBvcnQgeyBNZWRpYUNoYW5nZSB9IGZyb20gJy4uL21lZGlhLWNoYW5nZSc7XG5pbXBvcnQgeyBQcmludEhvb2sgfSBmcm9tICcuL3ByaW50LWhvb2snO1xuZGVjbGFyZSB0eXBlIENsZWFyQ2FsbGJhY2sgPSAoKSA9PiB2b2lkO1xuZGVjbGFyZSB0eXBlIFVwZGF0ZUNhbGxiYWNrID0gKHZhbDogYW55KSA9PiB2b2lkO1xuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50TWF0Y2hlciB7XG4gICAgZWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAga2V5OiBzdHJpbmc7XG4gICAgdmFsdWU6IGFueTtcbn1cbi8qKlxuICogTWVkaWFNYXJzaGFsbGVyIC0gcmVnaXN0ZXIgcmVzcG9uc2l2ZSB2YWx1ZXMgZnJvbSBkaXJlY3RpdmVzIGFuZFxuICogICAgICAgICAgICAgICAgICAgdHJpZ2dlciB0aGVtIGJhc2VkIG9uIG1lZGlhIHF1ZXJ5IGV2ZW50c1xuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNZWRpYU1hcnNoYWxsZXIge1xuICAgIHByb3RlY3RlZCBtYXRjaE1lZGlhOiBNYXRjaE1lZGlhO1xuICAgIHByb3RlY3RlZCBicmVha3BvaW50czogQnJlYWtQb2ludFJlZ2lzdHJ5O1xuICAgIHByb3RlY3RlZCBob29rOiBQcmludEhvb2s7XG4gICAgcHJpdmF0ZSBhY3RpdmF0ZWRCcmVha3BvaW50cztcbiAgICBwcml2YXRlIGVsZW1lbnRNYXA7XG4gICAgcHJpdmF0ZSBlbGVtZW50S2V5TWFwO1xuICAgIHByaXZhdGUgd2F0Y2hlck1hcDtcbiAgICBwcml2YXRlIHVwZGF0ZU1hcDtcbiAgICBwcml2YXRlIGNsZWFyTWFwO1xuICAgIHByaXZhdGUgc3ViamVjdDtcbiAgICBnZXQgYWN0aXZhdGVkQWxpYXMoKTogc3RyaW5nO1xuICAgIGNvbnN0cnVjdG9yKG1hdGNoTWVkaWE6IE1hdGNoTWVkaWEsIGJyZWFrcG9pbnRzOiBCcmVha1BvaW50UmVnaXN0cnksIGhvb2s6IFByaW50SG9vayk7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN0eWxlcyBvbiBicmVha3BvaW50IGFjdGl2YXRlcyBvciBkZWFjdGl2YXRlc1xuICAgICAqIEBwYXJhbSBtY1xuICAgICAqL1xuICAgIG9uTWVkaWFDaGFuZ2UobWM6IE1lZGlhQ2hhbmdlKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplIHRoZSBtYXJzaGFsbGVyIHdpdGggbmVjZXNzYXJ5IGVsZW1lbnRzIGZvciBkZWxlZ2F0aW9uIG9uIGFuIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gdXBkYXRlRm4gb3B0aW9uYWwgY2FsbGJhY2sgc28gdGhhdCBjdXN0b20gYnAgZGlyZWN0aXZlcyBkb24ndCBoYXZlIHRvIHJlLXByb3ZpZGUgdGhpc1xuICAgICAqIEBwYXJhbSBjbGVhckZuIG9wdGlvbmFsIGNhbGxiYWNrIHNvIHRoYXQgY3VzdG9tIGJwIGRpcmVjdGl2ZXMgZG9uJ3QgaGF2ZSB0byByZS1wcm92aWRlIHRoaXNcbiAgICAgKiBAcGFyYW0gZXh0cmFUcmlnZ2VycyBvdGhlciB0cmlnZ2VycyB0byBmb3JjZSBzdHlsZSB1cGRhdGVzIChlLmcuIGxheW91dCwgZGlyZWN0aW9uYWxpdHksIGV0YylcbiAgICAgKi9cbiAgICBpbml0KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBrZXk6IHN0cmluZywgdXBkYXRlRm4/OiBVcGRhdGVDYWxsYmFjaywgY2xlYXJGbj86IENsZWFyQ2FsbGJhY2ssIGV4dHJhVHJpZ2dlcnM/OiBPYnNlcnZhYmxlPGFueT5bXSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB2YWx1ZSBmb3IgYW4gZWxlbWVudCBhbmQga2V5IGFuZCBvcHRpb25hbGx5IGEgZ2l2ZW4gYnJlYWtwb2ludFxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSBicFxuICAgICAqL1xuICAgIGdldFZhbHVlKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBrZXk6IHN0cmluZywgYnA/OiBzdHJpbmcpOiBhbnk7XG4gICAgLyoqXG4gICAgICogd2hldGhlciB0aGUgZWxlbWVudCBoYXMgdmFsdWVzIGZvciBhIGdpdmVuIGtleVxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIGhhc1ZhbHVlKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBrZXk6IHN0cmluZyk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgYW4gaW5wdXQgb24gYSBkaXJlY3RpdmVcbiAgICAgKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCBpbiBxdWVzdGlvblxuICAgICAqIEBwYXJhbSBrZXkgdGhlIHR5cGUgb2YgdGhlIGRpcmVjdGl2ZSAoZS5nLiBmbGV4LCBsYXlvdXQtZ2FwLCBldGMpXG4gICAgICogQHBhcmFtIGJwIHRoZSBicmVha3BvaW50IHN1ZmZpeCAoZW1wdHkgc3RyaW5nID0gZGVmYXVsdClcbiAgICAgKiBAcGFyYW0gdmFsIHRoZSB2YWx1ZSBmb3IgdGhlIGJyZWFrcG9pbnRcbiAgICAgKi9cbiAgICBzZXRWYWx1ZShlbGVtZW50OiBIVE1MRWxlbWVudCwga2V5OiBzdHJpbmcsIHZhbDogYW55LCBicDogc3RyaW5nKTogdm9pZDtcbiAgICAvKiogVHJhY2sgZWxlbWVudCB2YWx1ZSBjaGFuZ2VzIGZvciBhIHNwZWNpZmljIGtleSAqL1xuICAgIHRyYWNrVmFsdWUoZWxlbWVudDogSFRNTEVsZW1lbnQsIGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxFbGVtZW50TWF0Y2hlcj47XG4gICAgLyoqIHVwZGF0ZSBhbGwgc3R5bGVzIGZvciBhbGwgZWxlbWVudHMgb24gdGhlIGN1cnJlbnQgYnJlYWtwb2ludCAqL1xuICAgIHVwZGF0ZVN0eWxlcygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGNsZWFyIHRoZSBzdHlsZXMgZm9yIGEgZ2l2ZW4gZWxlbWVudFxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIGNsZWFyRWxlbWVudChlbGVtZW50OiBIVE1MRWxlbWVudCwga2V5OiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIHVwZGF0ZSBhIGdpdmVuIGVsZW1lbnQgd2l0aCB0aGUgYWN0aXZhdGVkIHZhbHVlcyBmb3IgYSBnaXZlbiBrZXlcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGVFbGVtZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBrZXk6IHN0cmluZywgdmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogcmVsZWFzZSBhbGwgcmVmZXJlbmNlcyB0byBhIGdpdmVuIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqL1xuICAgIHJlbGVhc2VFbGVtZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiB0cmlnZ2VyIGFuIHVwZGF0ZSBmb3IgYSBnaXZlbiBlbGVtZW50IGFuZCBrZXkgKGUuZy4gbGF5b3V0KVxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIHRyaWdnZXJVcGRhdGUoZWxlbWVudDogSFRNTEVsZW1lbnQsIGtleT86IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqIENyb3NzLXJlZmVyZW5jZSBmb3IgSFRNTEVsZW1lbnQgd2l0aCBkaXJlY3RpdmUga2V5ICovXG4gICAgcHJpdmF0ZSBidWlsZEVsZW1lbnRLZXlNYXA7XG4gICAgLyoqXG4gICAgICogT3RoZXIgdHJpZ2dlcnMgdGhhdCBzaG91bGQgZm9yY2Ugc3R5bGUgdXBkYXRlczpcbiAgICAgKiAtIGRpcmVjdGlvbmFsaXR5XG4gICAgICogLSBsYXlvdXQgY2hhbmdlc1xuICAgICAqIC0gbXV0YXRpb25vYnNlcnZlciB1cGRhdGVzXG4gICAgICovXG4gICAgcHJpdmF0ZSB3YXRjaEV4dHJhVHJpZ2dlcnM7XG4gICAgLyoqIEJyZWFrcG9pbnQgbG9jYXRvciBieSBtZWRpYVF1ZXJ5ICovXG4gICAgcHJpdmF0ZSBmaW5kQnlRdWVyeTtcbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGZhbGxiYWNrIGJyZWFrcG9pbnQgZm9yIGEgZ2l2ZW4gZWxlbWVudCwgc3RhcnRpbmcgd2l0aCB0aGUgY3VycmVudCBicmVha3BvaW50XG4gICAgICogQHBhcmFtIGJwTWFwXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0QWN0aXZhdGVkVmFsdWVzO1xuICAgIC8qKlxuICAgICAqIFdhdGNoIGZvciBtZWRpYVF1ZXJ5IGJyZWFrcG9pbnQgYWN0aXZhdGlvbnNcbiAgICAgKi9cbiAgICBwcml2YXRlIG9ic2VydmVBY3RpdmF0aW9ucztcbn1cbmV4cG9ydCB7fTtcbiJdfQ==